// У нас есть два хомяка: шустрый (speedy) и ленивый (lazy); оба наследуют от общего объекта hamster.
// Когда мы кормим одного хомяка, второй тоже наедается. Почему? Как это исправить?

let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Этот хомяк нашёл еду
speedy.eat("apple");
alert(speedy.stomach); // apple

// У этого хомяка тоже есть еда. Почему? Исправьте
alert(lazy.stomach); // apple





// При выполнении метода speedy.eat, на моменте this.stomach происходит поиск свойства stomach у объекта, на который ссылается this, т.е. speedy. Собственного такого свойства у него нет, и поиск переходит к прототипу. В нем такое свойство находится и возвращается. Поскольку в свойстве содержится массив, возвращается ссылка на массив. Далее в этот массив, хранящийся в прототипе, добавляется элемент.
// Таким образом любой вызов метода eat всегда воздействует на свойство именно прототипа. А поскольку у объектов-наследников нет своих свойств stomach, обращение к stomach приводит к обращению к свойству прототипа.
// В результате и stomach, и eat одни на всех.

// Чтобы исправить ситуацию, можно сделать так, чтобы к моменту обращения this.stomach (в методе eat) у объекта-наследника было собственное свойство stomach:
hamster = {
  stomach: [],

  eat(food) {
    if (!this.hasOwnProperty('stomach')) this.stomach = [];
    this.stomach.push(food);
  }
};

// или

speedy = {
  stomach: [],
  __proto__: hamster
};

lazy = {
  stomach: [],
  __proto__: hamster
};